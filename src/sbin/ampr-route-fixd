#!/usr/bin/env perl

use strict;
use warnings;
use v5.10;
use autodie ':all';

use Data::Dumper;
use IPC::System::Simple qw(capture);
use Net::IPAddress::Filter;

use constant ROUTE_SHOW_CMD => qw(ip route show);
use constant ROUTE_CHANGE_CMD => qw(ip route change);
use constant AMPR_SUBNET => "44.0.0.0/8";

use constant SRC_IP_ADDR => "44.24.173.239";

main();

sub main {
    my $ampr_subnet = make_filter();

    while(1) {
        foreach my $route (get_routes()) {
            my @parts = split(/\s+/, $route);
            my $dest = $parts[0];

            next if $dest eq 'default';
            die "could not parse network address '$dest'" unless $dest =~ m,^([^/]+)(/(.+))?,;
            my ($ip, $mask) = ($1, $3);
            $mask = '32' unless defined $mask;
            next unless $ampr_subnet->in_filter($ip);

            check_src(@parts);
            check_mtu(@parts);
            check_window(@parts);
            check_rtt(@parts);
        }

        sleep(1);
    }

    exit(0);
}

sub get_routes {
    my @routes;

    foreach my $route (split("\n", capture(ROUTE_SHOW_CMD))) {
        $route =~ s/\s+$//;
        push(@routes, $route);
    }

    return @routes;
}

sub make_filter {
    my $filter = Net::IPAddress::Filter->new;
    $filter->add_range(AMPR_SUBNET);
    return $filter;
}

sub check_src {
    my (@parts) = @_;
    my $found_src = 0;

    for (my $i = 0; $i < $#parts; $i++) {
        my $token = $parts[$i];

        if ($token eq 'src') {
            # FIXME this should check the src value instead
            # of just seeing if one exists
            $found_src = 1;
            last;
        }
    }

    return if $found_src;

    system(ROUTE_CHANGE_CMD, @parts, 'src', SRC_IP_ADDR);
}

sub check_mtu {
    my (@parts) = @_;
    my $found_mtu = 0;

    for (my $i = 0; $i < $#parts; $i++) {
        my $token = $parts[$i];

        if ($token eq 'mtu') {
            # FIXME this should check the MTU value instead of just
            # seeing if it exists
            $found_mtu = 1;
            last;
        }
    }

    return if $found_mtu;

    system(ROUTE_CHANGE_CMD, @parts, qw(mtu 255));
}

sub check_window {
    my (@parts) = @_;
    my $found_mtu = 0;

    for (my $i = 0; $i < $#parts; $i++) {
        my $token = $parts[$i];

        if ($token eq 'window') {
            # FIXME this should check the MTU value instead of just
            # seeing if it exists
            $found_mtu = 1;
            last;
        }
    }

    return if $found_mtu;

    system(ROUTE_CHANGE_CMD, @parts, qw(window 1024));
}

sub check_rtt {
    my (@parts) = @_;
    my $found_mtu = 0;

    for (my $i = 0; $i < $#parts; $i++) {
        my $token = $parts[$i];

        if ($token eq 'rtt') {
            # FIXME this should check the MTU value instead of just
            # seeing if it exists
            $found_mtu = 1;
            last;
        }
    }

    return if $found_mtu;

    system(ROUTE_CHANGE_CMD, @parts, qw(rtt 1.5s));
}
